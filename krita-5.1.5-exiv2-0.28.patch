diff -up krita-5.1.5/plugins/impex/jpeg/kis_jpeg_converter.cc.3~ krita-5.1.5/plugins/impex/jpeg/kis_jpeg_converter.cc
--- krita-5.1.5/plugins/impex/jpeg/kis_jpeg_converter.cc.3~	2023-01-05 12:21:21.000000000 +0100
+++ krita-5.1.5/plugins/impex/jpeg/kis_jpeg_converter.cc	2023-05-18 07:26:05.668978933 +0200
@@ -20,6 +20,7 @@ extern "C" {
 }
 
 #include <exiv2/jpgimage.hpp>
+#include <exiv2/photoshop.hpp>
 
 #include <QFile>
 #include <QBuffer>
@@ -376,7 +377,7 @@ KisImportExportErrorCode KisJPEGConverte
             uint32_t sizeHdr = 0;
             // Find actual Iptc data within the APP13 segment
             if (!Exiv2::Photoshop::locateIptcIrb((Exiv2::byte*)(marker->data + 14),
-                                                 marker->data_length - 14, &record, &sizeHdr, &sizeIptc)) {
+                                                 marker->data_length - 14, &record, sizeHdr, sizeIptc)) {
                 if (sizeIptc) {
                     // Decode the IPTC data
                     QByteArray byteArray((const char*)(record + sizeHdr), sizeIptc);
diff -up krita-5.1.5/plugins/impex/tiff/kis_tiff_export.cc.3~ krita-5.1.5/plugins/impex/tiff/kis_tiff_export.cc
--- krita-5.1.5/plugins/impex/tiff/kis_tiff_export.cc.3~	2023-01-05 12:21:21.000000000 +0100
+++ krita-5.1.5/plugins/impex/tiff/kis_tiff_export.cc	2023-05-18 07:26:05.668978933 +0200
@@ -206,7 +206,7 @@ KisImportExportErrorCode KisTIFFExport::
         try {
             KisExiv2IODevice::ptr_type basicIoDevice(new KisExiv2IODevice(filename()));
 
-            const std::unique_ptr<Exiv2::Image> img(Exiv2::ImageFactory::open(basicIoDevice).release());
+            const std::unique_ptr<Exiv2::Image> img(Exiv2::ImageFactory::open(std::move(basicIoDevice)).release());
 
             img->readMetadata();
 
@@ -241,8 +241,8 @@ KisImportExportErrorCode KisTIFFExport::
             }
             // Write metadata
             img->writeMetadata();
-        } catch (Exiv2::AnyError &e) {
-            errFile << "Failed injecting TIFF metadata:" << e.code()
+        } catch (Exiv2::Error &e) {
+            errFile << "Failed injecting TIFF metadata:" << static_cast<int>(e.code())
                     << e.what();
         }
     }
diff -up krita-5.1.5/plugins/impex/tiff/kis_tiff_import.cc.3~ krita-5.1.5/plugins/impex/tiff/kis_tiff_import.cc
--- krita-5.1.5/plugins/impex/tiff/kis_tiff_import.cc.3~	2023-01-05 12:21:21.000000000 +0100
+++ krita-5.1.5/plugins/impex/tiff/kis_tiff_import.cc	2023-05-18 07:26:05.669978941 +0200
@@ -1840,7 +1840,7 @@ KisTIFFImport::convert(KisDocument *docu
         try {
             KisExiv2IODevice::ptr_type basicIoDevice(new KisExiv2IODevice(filename()));
 
-            const std::unique_ptr<Exiv2::Image> readImg(Exiv2::ImageFactory::open(basicIoDevice).release());
+            const std::unique_ptr<Exiv2::Image> readImg(Exiv2::ImageFactory::open(std::move(basicIoDevice)).release());
 
             readImg->readMetadata();
 
@@ -1908,8 +1908,8 @@ KisTIFFImport::convert(KisDocument *docu
 
             // Inject the data as any other IOBackend
             io->loadFrom(layer->metaData(), &ioDevice);
-        } catch (Exiv2::AnyError &e) {
-            errFile << "Failed metadata import:" << e.code() << e.what();
+        } catch (Exiv2::Error &e) {
+            errFile << "Failed metadata import:" << static_cast<int>(e.code()) << e.what();
         }
     }
 
diff -up krita-5.1.5/plugins/metadata/common/kis_exiv2_common.h.3~ krita-5.1.5/plugins/metadata/common/kis_exiv2_common.h
--- krita-5.1.5/plugins/metadata/common/kis_exiv2_common.h.3~	2023-01-05 12:21:21.000000000 +0100
+++ krita-5.1.5/plugins/metadata/common/kis_exiv2_common.h	2023-05-18 07:26:05.669978941 +0200
@@ -19,7 +19,7 @@
 
 // Convert an exiv value to a KisMetaData value
 inline KisMetaData::Value
-exivValueToKMDValue(const Exiv2::Value::AutoPtr value,
+exivValueToKMDValue(const Exiv2::Value::UniquePtr value,
                     bool forceSeq,
                     KisMetaData::Value::ValueType arrayType = KisMetaData::Value::UnorderedArray)
 {
@@ -42,11 +42,11 @@ exivValueToKMDValue(const Exiv2::Value::
     case Exiv2::signedShort:
     case Exiv2::signedLong: {
         if (value->count() == 1 && !forceSeq) {
-            return KisMetaData::Value((int)value->toLong());
+            return KisMetaData::Value((int)value->toUint32());
         } else {
             QList<KisMetaData::Value> array;
             for (int i = 0; i < value->count(); i++)
-                array.push_back(KisMetaData::Value((int)value->toLong(i)));
+                array.push_back(KisMetaData::Value((int)value->toUint32(i)));
             return KisMetaData::Value(array, arrayType);
         }
     }
diff -up krita-5.1.5/plugins/metadata/common/KisExiv2IODevice.cpp.3~ krita-5.1.5/plugins/metadata/common/KisExiv2IODevice.cpp
--- krita-5.1.5/plugins/metadata/common/KisExiv2IODevice.cpp.3~	2023-01-05 12:21:21.000000000 +0100
+++ krita-5.1.5/plugins/metadata/common/KisExiv2IODevice.cpp	2023-05-18 07:27:58.176856613 +0200
@@ -39,7 +39,7 @@ int KisExiv2IODevice::close()
     return 0;
 }
 
-long KisExiv2IODevice::write(const Exiv2::byte *data, long wcount)
+size_t KisExiv2IODevice::write(const Exiv2::byte *data, size_t wcount)
 {
     if (!m_file.isWritable()) {
         qWarning() << "KisExiv2IODevice: File not open for writing.";
@@ -53,7 +53,7 @@ long KisExiv2IODevice::write(const Exiv2
     return 0;
 }
 
-long KisExiv2IODevice::write(Exiv2::BasicIo &src)
+size_t KisExiv2IODevice::write(Exiv2::BasicIo &src)
 {
     if (static_cast<BasicIo *>(this) == &src) {
         return 0;
@@ -88,15 +88,15 @@ int KisExiv2IODevice::putb(Exiv2::byte d
     }
 }
 
-Exiv2::DataBuf KisExiv2IODevice::read(long rcount)
+Exiv2::DataBuf KisExiv2IODevice::read(size_t rcount)
 {
     Exiv2::DataBuf buf(rcount);
-    const long readCount = read(buf.pData_, buf.size_);
-    buf.size_ = readCount;
+    const size_t readCount = read(buf.data(), buf.size());
+    buf.resize(readCount);
     return buf;
 }
 
-long KisExiv2IODevice::read(Exiv2::byte *buf, long rcount)
+size_t KisExiv2IODevice::read(Exiv2::byte *buf, size_t rcount)
 {
     const qint64 bytesRead = m_file.read(reinterpret_cast<char *>(buf), rcount);
     if (bytesRead > 0) {
@@ -202,7 +202,7 @@ int KisExiv2IODevice::munmap()
     return 0;
 }
 
-long KisExiv2IODevice::tell() const
+size_t KisExiv2IODevice::tell() const
 {
     return m_file.pos();
 }
@@ -231,9 +231,9 @@ bool KisExiv2IODevice::eof() const
     return m_file.atEnd();
 }
 
-std::string KisExiv2IODevice::path() const
+const std::string &KisExiv2IODevice::path() const noexcept
 {
-    return filePathQString().toStdString();
+    return std::move(filePathQString().toStdString());
 }
 
 bool KisExiv2IODevice::open(QFile::OpenMode mode)
diff -up krita-5.1.5/plugins/metadata/common/KisExiv2IODevice.h.3~ krita-5.1.5/plugins/metadata/common/KisExiv2IODevice.h
--- krita-5.1.5/plugins/metadata/common/KisExiv2IODevice.h.3~	2023-01-05 12:21:21.000000000 +0100
+++ krita-5.1.5/plugins/metadata/common/KisExiv2IODevice.h	2023-05-18 07:26:05.669978941 +0200
@@ -18,18 +18,18 @@
 class KRITAEXIFCOMMON_EXPORT KisExiv2IODevice : public Exiv2::BasicIo
 {
 public:
-    using ptr_type = Exiv2::BasicIo::AutoPtr;
+    using ptr_type = Exiv2::BasicIo::UniquePtr;
 
     KisExiv2IODevice(QString path);
     ~KisExiv2IODevice() override;
 
     int open() override;
     int close() override;
-    long write(const Exiv2::byte *data, long wcount) override;
-    long write(Exiv2::BasicIo &src) override;
+    size_t write(const Exiv2::byte *data, size_t wcount) override;
+    size_t write(Exiv2::BasicIo &src) override;
     int putb(Exiv2::byte data) override;
-    Exiv2::DataBuf read(long rcount) override;
-    long read(Exiv2::byte *buf, long rcount) override;
+    Exiv2::DataBuf read(size_t rcount) override;
+    size_t read(Exiv2::byte *buf, size_t rcount) override;
     int getb() override;
     void transfer(BasicIo &src) override;
 #if defined(_MSC_VER)
@@ -40,12 +40,13 @@ public:
 
     Exiv2::byte *mmap(bool isWriteable = false) override;
     int munmap() override;
-    long tell() const override;
+    size_t tell() const override;
     size_t size() const override;
     bool isopen() const override;
     int error() const override;
     bool eof() const override;
-    std::string path() const override;
+    const std::string &path() const noexcept override;
+    void populateFakeData() override {}
 
 private:
     bool open(QFile::OpenMode mode);
diff -up krita-5.1.5/plugins/metadata/exif/kis_exif_io.cpp.3~ krita-5.1.5/plugins/metadata/exif/kis_exif_io.cpp
--- krita-5.1.5/plugins/metadata/exif/kis_exif_io.cpp.3~	2023-01-05 12:21:21.000000000 +0100
+++ krita-5.1.5/plugins/metadata/exif/kis_exif_io.cpp	2023-05-18 07:26:05.670978949 +0200
@@ -31,7 +31,7 @@
 // ---- Exception conversion functions ---- //
 
 // convert ExifVersion and FlashpixVersion to a KisMetaData value
-KisMetaData::Value exifVersionToKMDValue(const Exiv2::Value::AutoPtr value)
+KisMetaData::Value exifVersionToKMDValue(const Exiv2::Value::UniquePtr value)
 {
     const Exiv2::DataValue *dvalue = dynamic_cast<const Exiv2::DataValue *>(&*value);
     if (dvalue) {
@@ -55,13 +55,13 @@ Exiv2::Value *kmdValueToExifVersion(cons
 }
 
 // Convert an exif array of integer string to a KisMetaData array of integer
-KisMetaData::Value exifArrayToKMDIntOrderedArray(const Exiv2::Value::AutoPtr value)
+KisMetaData::Value exifArrayToKMDIntOrderedArray(const Exiv2::Value::UniquePtr value)
 {
     QList<KisMetaData::Value> v;
     const Exiv2::DataValue *dvalue = dynamic_cast<const Exiv2::DataValue *>(&*value);
     if (dvalue) {
         for (long i = 0; i < dvalue->count(); i++) {
-            v.push_back({(int)dvalue->toLong(i)});
+            v.push_back({(int)dvalue->toUint32(i)});
         }
     } else {
         Q_ASSERT(value->typeId() == Exiv2::asciiString);
@@ -81,7 +81,7 @@ Exiv2::Value *kmdIntOrderedArrayToExifAr
     return new Exiv2::DataValue(v.data(), static_cast<long>(v.size()));
 }
 
-QDateTime exivValueToDateTime(const Exiv2::Value::AutoPtr value)
+QDateTime exivValueToDateTime(const Exiv2::Value::UniquePtr value)
 {
     return QDateTime::fromString(value->toString().c_str(), Qt::ISODate);
 }
@@ -115,7 +115,7 @@ Exiv2::ByteOrder invertByteOrder(Exiv2::
     return Exiv2::invalidByteOrder;
 }
 
-KisMetaData::Value exifOECFToKMDOECFStructure(const Exiv2::Value::AutoPtr value, Exiv2::ByteOrder order)
+KisMetaData::Value exifOECFToKMDOECFStructure(const Exiv2::Value::UniquePtr value, Exiv2::ByteOrder order)
 {
     QMap<QString, KisMetaData::Value> oecfStructure;
     const Exiv2::DataValue *dvalue = dynamic_cast<const Exiv2::DataValue *>(&*value);
@@ -202,7 +202,7 @@ Exiv2::Value *kmdOECFStructureToExifOECF
     return new Exiv2::DataValue((const Exiv2::byte *)array.data(), array.size());
 }
 
-KisMetaData::Value deviceSettingDescriptionExifToKMD(const Exiv2::Value::AutoPtr value)
+KisMetaData::Value deviceSettingDescriptionExifToKMD(const Exiv2::Value::UniquePtr value)
 {
     QMap<QString, KisMetaData::Value> deviceSettingStructure;
     QByteArray array;
@@ -258,7 +258,7 @@ Exiv2::Value *deviceSettingDescriptionKM
     return new Exiv2::DataValue((const Exiv2::byte *)array.data(), array.size());
 }
 
-KisMetaData::Value cfaPatternExifToKMD(const Exiv2::Value::AutoPtr value, Exiv2::ByteOrder order)
+KisMetaData::Value cfaPatternExifToKMD(const Exiv2::Value::UniquePtr value, Exiv2::ByteOrder order)
 {
     QMap<QString, KisMetaData::Value> cfaPatternStructure;
     const Exiv2::DataValue *dvalue = dynamic_cast<const Exiv2::DataValue *>(&*value);
@@ -310,9 +310,9 @@ Exiv2::Value *cfaPatternKMDToExif(const
 
 // Read and write Flash //
 
-KisMetaData::Value flashExifToKMD(const Exiv2::Value::AutoPtr value)
+KisMetaData::Value flashExifToKMD(const Exiv2::Value::UniquePtr value)
 {
-    const uint16_t v = static_cast<uint16_t>(value->toLong());
+    const uint16_t v = static_cast<uint16_t>(value->toUint32());
     QMap<QString, KisMetaData::Value> flashStructure;
     bool fired = (v & 0x01); // bit 1 is whether flash was fired or not
     flashStructure["Fired"] = QVariant(fired);
@@ -465,7 +465,7 @@ bool KisExifIO::saveTo(KisMetaData::Stor
                                 << exivKey; // << " of KMD value" << entry.value();
                 }
             }
-        } catch (Exiv2::AnyError &e) {
+        } catch (Exiv2::Error &e) {
             dbgMetaData << "exiv error " << e.what();
         }
     }
diff -up krita-5.1.5/plugins/metadata/iptc/kis_iptc_io.cpp.3~ krita-5.1.5/plugins/metadata/iptc/kis_iptc_io.cpp
--- krita-5.1.5/plugins/metadata/iptc/kis_iptc_io.cpp.3~	2023-01-05 12:21:21.000000000 +0100
+++ krita-5.1.5/plugins/metadata/iptc/kis_iptc_io.cpp	2023-05-18 07:26:05.670978949 +0200
@@ -110,7 +110,7 @@ bool KisIptcIO::saveTo(KisMetaData::Stor
                 if (v && v->typeId() != Exiv2::invalidTypeId) {
                     iptcData.add(iptcKey, v);
                 }
-            } catch (Exiv2::AnyError &e) {
+            } catch (Exiv2::Error &e) {
                 dbgMetaData << "exiv error " << e.what();
             }
         }
@@ -128,7 +128,7 @@ bool KisIptcIO::saveTo(KisMetaData::Stor
         header.append(photoshopBimId_);
         header.append(photoshopIptc_);
         header.append(QByteArray(2, 0));
-        qint32 size = rawData.size_;
+        qint32 size = rawData.size();
         QByteArray sizeArray(4, 0);
         sizeArray[0] = (char)((size & 0xff000000) >> 24);
         sizeArray[1] = (char)((size & 0x00ff0000) >> 16);
@@ -138,7 +138,7 @@ bool KisIptcIO::saveTo(KisMetaData::Stor
         ioDevice->write(header);
     }
 
-    ioDevice->write((const char *)rawData.pData_, rawData.size_);
+    ioDevice->write((const char *)rawData.c_data(), rawData.size());
     ioDevice->close();
     return true;
 }
diff -up krita-5.1.5/plugins/metadata/xmp/kis_xmp_io.cpp.3~ krita-5.1.5/plugins/metadata/xmp/kis_xmp_io.cpp
--- krita-5.1.5/plugins/metadata/xmp/kis_xmp_io.cpp.3~	2023-01-05 12:21:21.000000000 +0100
+++ krita-5.1.5/plugins/metadata/xmp/kis_xmp_io.cpp	2023-05-18 07:26:05.670978949 +0200
@@ -248,7 +248,7 @@ bool KisXMPIO::loadFrom(KisMetaData::Sto
                     Q_ASSERT(schema);
                 }
             }
-            const Exiv2::Value::AutoPtr value = it->getValue();
+            const Exiv2::Value::UniquePtr value = it->getValue();
 
             QString structName;
             int arrayIndex = -1;
